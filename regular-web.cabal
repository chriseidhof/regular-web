Name:            regular-web
Version:         0.1
Synopsis:        Some generic functions for the web
License:         BSD3
License-file:    LICENSE
Category:        Generics, Web
Copyright:       (c) Chris Eidhof
Author:          Chris Eidhof
Maintainer:      Chris Eidhof <chris+hackage@eidhof.nl>
Homepage:        http://github.com/chriseidhof/basil
Exposed-Modules:   Generics.Regular.Formlets
                 , Generics.Regular.Views
                 , Generics.Regular.JSON
Other-Modules:   Generics.Regular.Extras
Build-Type:      Simple
hs-source-dirs:  src
Build-Depends:   base >= 4, 
                 mtl,
                 xhtml,
                 formlets == 0.6.1,
                 applicative-extras,
                 regular >= 0.1.0.2,
                 fclabels >= 0.4.2,
                 json >= 0.4.3

Description:     This package implements some generic functions for the web. 
                 .
                 > {-# LANGUAGE TemplateHaskell, EmptyDataDecls, TypeFamilies #-}
                 >
                 > module Example where
                 > 
                 > import Generics.Regular
                 > import Generics.Regular.Views
                 > import Generics.Regular.Formlets
                 > import Control.Monad.Identity
                 > import Control.Applicative
                 > import qualified Text.XHtml.Strict as X
                 > import qualified Text.XHtml.Strict.Formlets as F
                 .
                 Consider the following two datatypes @Person@ and @Place@:
                 .
                 > data Person = Person {
                 >    _name   :: String
                 >  , _age    :: Int
                 >  , _isMale :: Bool
                 >  , _place  :: Place
                 > }
                 .
                 > data Place = Place {
                 >     _city      :: String
                 >   , _country   :: String
                 >   , _continent :: String
                 >   }
                 .
                 We can now derive a @Regular@ instance for the @Person@ datatype using Template
                 Haskell:
                 .
                 > $(deriveAll ''Place  "PFPlace")
                 > $(deriveAll ''Person "PFPerson")
                 >
                 > type instance PF Place  = PFPlace
                 > type instance PF Person = PFPerson
                 .
                 We can construct an example person:
                 .
                 > location = Place "Utrecht" "The Netherlands" "Europe"
                 > chris    = Person "chris" 25 True location
                 .
                 We can now generate some @Html@ for the @location@:
                 .
                 > example0 :: X.Html
                 > example0 = ghtml location
                 .
                 If we try to generate @Html@ for the @chris@ value, we get an error:
                 .
                 > -- No instance for (Html Place)
                 .
                 We can easily make @Place@ an instance of @Html@:
                 .
                 > instance Html Place where html = ghtml
                 .
                 More interestingly, we can generically build @Formlet@s this way:
                 .
                 > instance Formlet Place where formlet = gformlet
                 .
                 > personForm :: XFormlet Identity Person
                 > personForm = gformlet
                 .
                 We can print @formHtml@ to get the @Html@ of the form with the @chris@ value
                 already filled in:
                 .
                 > (_, Identity formHtml, _) = F.runFormState [] (personForm (Just chris))
                 .
                 Unfortunately, we need to give an @Applicative@ instance for the @Identity@
                 monad.
                 .
                 > instance Applicative Identity where pure = return; (<*>) = ap
